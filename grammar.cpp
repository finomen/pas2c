#include <boost/config/warning_disable.hpp>

#include <boost/spirit/include/qi.hpp>

#include <boost/spirit/include/support.hpp>


#include <boost/spirit/include/phoenix_container.hpp>
#include <boost/spirit/include/phoenix_core.hpp>
#include <boost/spirit/include/phoenix_operator.hpp>
#include <boost/spirit/include/phoenix_fusion.hpp>
#include <boost/spirit/include/phoenix_stl.hpp>
#include <boost/spirit/include/phoenix_object.hpp>

#include <boost/lexical_cast.hpp>

namespace qi = boost::spirit::qi;
namespace ascii = boost::spirit::ascii;
namespace spirit = boost::spirit;
namespace phoenix = boost::phoenix;

struct pascal_grammar :
    qi::grammar<std::string::const_iterator, std::string(), ascii::space_type>
{
    pascal_grammar() :
        base_type(file_)
    {
        using qi::lit;
        using qi::lexeme;
        using ascii::char_;
        using ascii::alnum;
        using ascii::no_case;
        using ascii::string;
        using phoenix::at_c;
        using phoenix::val;
        using qi::omit;
        using namespace qi::labels;

        squote = char_("'") [_val += "\""];
        dquote = char_("\"") [_val += "'"];
        uint_ = lexeme[char_("1-9") >> *char_("0-9")];
        int_ = -char_("+-") >> lexeme[char_("1-9") >> *char_("0-9")];
        double_ = -int_ [_val += _1] >> lit(".") [_val += "."] >> uint_ [_val += _1];
       
        identifier = lexeme[char_("a-zA-Z_") >> *(alnum | char_("_"))];

        char_string = squote >> *~char_("'") >> squote;
        cchar_ = dquote >> ~char_("\"") >> dquote; //FIXME: "\""

        identifier_list = identifier [_val += _1] % lit(',') [_val += ", "];

        relop %= lit("=") [_val += "=="]
            | lit("<>") [_val += "!="]
            | lit("<") [_val += "<"]
            | lit(">") [_val += ">"]
            | lit("<=") [_val += "<="]
            | lit(">=") [_val += ">="]
            | no_case[lit("IN")] [_val += "IN"]; //FIXME: IN is special case
            
        addop %= lit("+") [_val += "+"]
            | lit("-") [_val += "-"]
            | no_case[lit("OR")] [_val += "||"];
            
        mulop %= lit("*") [_val += "*"]
            | lit("/") [_val += "/"]
            | no_case[lit("DIV")] [_val += "/"]
            | no_case[lit("MOD")] [_val += "%"]
            | no_case[lit("AND")] [_val += "&&"];
            
        sop %= lit("+") [_val += "+"]
            | lit("-") [_val += "-"];

        eop %= lit("**") [_val += "STARSTAR"]; //FIXME: STARSTAR is pow
        notop %= no_case[lit("NOT")] [_val += "!"];


        nil_ = no_case[lit("NIL")] [val("0")];

        label = char_("[1-9]") >> *char_("[0-9]");
        label_list = label % lit(',');
        label_declaration_part = label_list [_val = ""]>> lit(';'); //TODO: what is this&

        constant_definition = identifier [_val = "const auto " + _1] >> lit('=') [_val += " = "] >>
            cexpression_ [_val += _1] >> lit(';') [_val += ";"];
        constant_list = *(constant_definition [_val += _1 + "\n"]);
        constant_definition_part =
        		no_case[lit("CONST")] [_val += "/**\n * Constants\n */\n"]
			    >> constant_list [_val += _1];

        cexpression_ = ccomparsion [_val = _1] | csimple_expression [_val = _1];
        ccomparsion = csimple_expression >> relop >> csimple_expression;

        csimple_expression = cadd [_val = _1] | cterm [_val = _1];
        cadd = cterm [_val += _1] >> addop [_val += " " + _1 + " "] >> csimple_expression [_val += _1];

        cterm = cmul [_val = _1] | cfactor [_val = _1];
        cmul = cfactor [_val += _1] >> mulop [_val += " " + _1 + " "] >> cterm [_val += _1];

        cfactor = csign [_val = _1] | cexponentation [_val = _1];
        csign = sop >> cexponentation;

        cexponentation = cexp [_val = _1] | cprimary [_val = _1];
        cexp = cprimary [_val = "pow(" + _1 + ", "] >> eop
        		>> cexponentation [_val += _1 +")"];

        cprimary = identifier [_val = _1]
        		| (lit("(") >> cexpression_ >> lit(")")) [_val = _1]
        		| unsigned_constant_ [_val = _1]
        		| cpnot [_val = _1];

        cpnot = notop >> cprimary;

        unsigned_constant_ = uint_ |
        		double_ |
        		char_string |
        		nil_ ; //FIXME: double must be unsigned and human-readable

        constant_ = int_ |
        		double_  |
        		char_string |
        		identifier |
        		cchar_ ; //WTF?? identifier here?

        file_ = program_.alias() /*| unit_*/;

        program_ = no_case[lit("PROGRAM")]
			    [_val = "/**\n * Autogenerated from "]
				>> identifier [_val += _1] >> -(lit("(") >>
        		identifier_list >> lit(")")) >> lit(";") [_val += "\n */\n"] >> block_ [_val += _1] >> lit(".");

        block_ = -label_declaration_part >>
        		-constant_definition_part >>
        		-type_definition_part
				/*>> variable_declaration_part >> procedure_and_function_declaration_part
				>> statement_part*/;


		type_definition_list = *type_definition;
		type_definition_part = no_case[lit("TYPE")] [_val += "/**\n * Types\n */\n"] >> type_definition_list [_val += _1];
		type_definition = (identifier >> lit("=") >> type_denoter ) [_val += "typedef " + _2 + " " + _1]>> lit(";") [_val += ";\n"];
		type_denoter = new_type [_val = _1] | identifier [_val = _1];
		new_type = new_ordinal_type | new_structured_type | new_pointer_type;
		new_pointer_type = lit("^") [_val += "*"] >> identifier [_val += _1];
		new_ordinal_type = subrange_type_ | enumerated_type_;
		enumerated_type_ = lit("(") [_val += "enum {"] >> identifier_list [_val += _1] >> lit(")") [_val += "}"];
		subrange_type_ = constant_ [_val += "pascal_subrange<" + _1 + ", "] >> lit("..") >> constant_ [_val += _1 + ">"];

		new_structured_type = -lit("PACKED") >> structured_type_;
		structured_type_ = array_type.alias() /*| record_type | set_type | file_type*/;
		array_type = no_case[lit("ARRAY")] [_val = "pascal_array<"]
			>>  (lit("[") >> index_list >> lit("]") >>
			no_case[lit("OF")] >> type_denoter ) [_val += _2 + ", " + _1 + " >"];
		index_list = (new_ordinal_type [_val += _1] | identifier [_val += _1])  % lit(",") [_val += ", "];

    }

	typedef std::string::const_iterator iterator;

	// Ugly hack
	qi::rule<iterator, std::string(), ascii::space_type> squote;
	qi::rule<iterator, std::string(), ascii::space_type> dquote;
	qi::rule<iterator, std::string(), ascii::space_type> uint_;
	qi::rule<iterator, std::string(), ascii::space_type> int_;
	qi::rule<iterator, std::string(), ascii::space_type> double_;

	qi::rule<iterator, std::string(), ascii::space_type> identifier;
	qi::rule<iterator, std::string(), ascii::space_type> char_string;
	qi::rule<iterator, std::string(), ascii::space_type> cchar_;
	qi::rule<iterator, std::string(), ascii::space_type> identifier_list;

	qi::rule<iterator, std::string(), ascii::space_type> relop;
	qi::rule<iterator, std::string(), ascii::space_type> addop;
	qi::rule<iterator, std::string(), ascii::space_type> mulop;
	qi::rule<iterator, std::string(), ascii::space_type> sop;
	qi::rule<iterator, std::string(), ascii::space_type> eop;
	qi::rule<iterator, std::string(), ascii::space_type> notop;

	qi::rule<iterator, std::string(), ascii::space_type> label;
	qi::rule<iterator, std::string(), ascii::space_type> label_list;
	qi::rule<iterator, std::string(), ascii::space_type> label_declaration_part;

	qi::rule<iterator, std::string(), ascii::space_type> constant_definition;
	qi::rule<iterator, std::string(), ascii::space_type> constant_list;
	qi::rule<iterator, std::string(), ascii::space_type> constant_definition_part;

	qi::rule<iterator, std::string(), ascii::space_type> cexpression_;
	qi::rule<iterator, std::string(), ascii::space_type> csimple_expression;

	qi::rule<iterator, std::string(), ascii::space_type> cterm;
	qi::rule<iterator, std::string(), ascii::space_type> cfactor;
	qi::rule<iterator, std::string(), ascii::space_type> cexponentation;
	qi::rule<iterator, std::string(), ascii::space_type> cprimary;
	qi::rule<iterator, std::string(), ascii::space_type> unsigned_constant_;
	qi::rule<iterator, std::string(), ascii::space_type> constant_;

	qi::rule<iterator, std::string(), ascii::space_type> nil_;

	/// Temp rules
	qi::rule<iterator, std::string(), ascii::space_type> ccomparsion;
	qi::rule<iterator, std::string(), ascii::space_type> cadd;
	qi::rule<iterator, std::string(), ascii::space_type> cmul;
	qi::rule<iterator, std::string(), ascii::space_type> csign;
	qi::rule<iterator, std::string(), ascii::space_type> cexp;
	qi::rule<iterator, std::string(), ascii::space_type> cpnot;

	qi::rule<iterator, std::string(), ascii::space_type> file_;
	qi::rule<iterator, std::string(), ascii::space_type> program_;

	qi::rule<iterator, std::string(), ascii::space_type> block_;

	qi::rule<iterator, std::string(), ascii::space_type> type_definition;
	qi::rule<iterator, std::string(), ascii::space_type> type_definition_list;
	qi::rule<iterator, std::string(), ascii::space_type> type_definition_part;
	qi::rule<iterator, std::string(), ascii::space_type> type_denoter;
	qi::rule<iterator, std::string(), ascii::space_type> new_type;
	qi::rule<iterator, std::string(), ascii::space_type> new_pointer_type;
	qi::rule<iterator, std::string(), ascii::space_type> new_ordinal_type;
	qi::rule<iterator, std::string(), ascii::space_type> enumerated_type_;
	qi::rule<iterator, std::string(), ascii::space_type> subrange_type_;
	qi::rule<iterator, std::string(), ascii::space_type> structured_type_;
	qi::rule<iterator, std::string(), ascii::space_type> new_structured_type;

	qi::rule<iterator, std::string(), ascii::space_type> array_type;
	qi::rule<iterator, std::string(), ascii::space_type> index_list;


    
};

#include <fstream>
#include <iostream>

int main() {
	const char * filename = "test.pas";
	std::ifstream in(filename, std::ios_base::in);

	if (!in)
	{
		std::cerr << "Error: Could not open input file: "
			<< filename << std::endl;
		return 1;
	}

	std::string storage;
	in.unsetf(std::ios::skipws);
	std::copy(
		std::istream_iterator<char>(in),
		std::istream_iterator<char>(),
		std::back_inserter(storage));


	pascal_grammar structure_;

	std::string ast;

	using boost::spirit::ascii::space;
	std::string::const_iterator iter = storage.begin();
	std::string::const_iterator end = storage.end();
	bool r = phrase_parse(iter, end, structure_, space, ast);
	if (r && iter == end) {
		std::cout << ast << std::endl;
	} else {
        std::string::const_iterator some = iter+60;
        std::string context(iter, (some>end)?end:some);
        std::cerr << "-------------------------\n";
        std::cerr << "Parsing failed\n";
        std::cerr << "stopped at: \"" << context << "...\"\n";
        std::cerr << "-------------------------\n";
        return 1;
    }

	return 0;
}

